

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { 
    getAuth, GoogleAuthProvider, signInWithPopup, 
    onAuthStateChanged, setPersistence, browserLocalPersistence 
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDXpmQTDZgn_JvtgrEH3tVLzb-XyggLs_M",
    authDomain: "midnight-library-satyam-media.firebaseapp.com",
    projectId: "midnight-library-satyam-media",
    appId: "1:842047619495:web:7483bc7e4a9029d6dc7682"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);

  // ðŸ”¥ LOGIN REMEMBER FIX
  setPersistence(auth, browserLocalPersistence);

  const provider = new GoogleAuthProvider();

  document.getElementById("loginBtn").onclick = async () => {
    try {
      await signInWithPopup(auth, provider);
    } catch (e) {
      alert(e.message);
    }
  };

  onAuthStateChanged(auth, (user) => {
    if (user) {
      document.getElementById("authGate").style.display = "none";
      document.getElementById("universe").classList.remove("hidden");
    }
  });
</script>


// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getAnalytics } from "firebase/analytics";
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyDXpmQTDZgn_JvtgrEH3tVLzb-XyggLs_M",
  authDomain: "midnight-library-satyam-media.firebaseapp.com",
  projectId: "midnight-library-satyam-media",
  storageBucket: "midnight-library-satyam-media.firebasestorage.app",
  messagingSenderId: "842047619495",
  appId: "1:842047619495:web:7483bc7e4a9029d6dc7682",
  measurementId: "G-CGDLDBT4HH"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const analytics = getAnalytics(app);


import { sql } from "drizzle-orm";
import { pgTable, text, varchar } from "drizzle-orm/pg-core";
import { pgTable, text, serial, integer, boolean, timestamp, date } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
import { relations } from "drizzle-orm";
// === USERS ===
export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  phone: text("phone").notNull().unique(), // Acts as username for login
  role: text("role", { enum: ["customer", "barber"] }).notNull(),
  location: text("location"), // Optional for customers
  createdAt: timestamp("created_at").defaultNow(),
});
export const insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true,
export const insertUserSchema = createInsertSchema(users).omit({ id: true, createdAt: true });
export type User = typeof users.$inferSelect;
export type InsertUser = z.infer<typeof insertUserSchema>;
// === SALONS ===
export const salons = pgTable("salons", {
  id: serial("id").primaryKey(),
  ownerId: integer("owner_id").references(() => users.id).notNull(),
  name: text("name").notNull(),
  location: text("location").notNull(),
  phone: text("phone").notNull(),
  isOpen: boolean("is_open").default(false),
  isOnBreak: boolean("is_on_break").default(false),
  breakStartTime: timestamp("break_start_time"),
  // We track the current serving token and the last issued token
  currentToken: integer("current_token").default(0),
  lastIssuedToken: integer("last_issued_token").default(0), 
  lastTokenReset: date("last_token_reset").defaultNow(),
});
export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;
export const salonsRelations = relations(salons, ({ one, many }) => ({
  owner: one(users, {
    fields: [salons.ownerId],
    references: [users.id],
  }),
  services: many(services),
  queue: many(queueEntries),
}));
export const insertSalonSchema = createInsertSchema(salons).omit({ 
  id: true, 
  currentToken: true, 
  lastIssuedToken: true,
  lastTokenReset: true,
  breakStartTime: true
});
export type Salon = typeof salons.$inferSelect;
export type InsertSalon = z.infer<typeof insertSalonSchema>;
// === SERVICES ===
export const services = pgTable("services", {
  id: serial("id").primaryKey(),
  salonId: integer("salon_id").references(() => salons.id).notNull(),
  name: text("name").notNull(),
  durationMinutes: integer("duration_minutes").notNull(),
  price: integer("price").notNull(),
});
export const servicesRelations = relations(services, ({ one }) => ({
  salon: one(salons, {
    fields: [services.salonId],
    references: [salons.id],
  }),
}));
export const insertServiceSchema = createInsertSchema(services).omit({ id: true });
export type Service = typeof services.$inferSelect;
export type InsertService = z.infer<typeof insertServiceSchema>;
// === QUEUE ENTRIES ===
export const queueEntries = pgTable("queue_entries", {
  id: serial("id").primaryKey(),
  salonId: integer("salon_id").references(() => salons.id).notNull(),
  customerId: integer("customer_id").references(() => users.id).notNull(),
  serviceId: integer("service_id").references(() => services.id).notNull(),
  tokenNumber: integer("token_number").notNull(),
  status: text("status", { enum: ["waiting", "completed", "cancelled"] }).default("waiting"),
  createdAt: timestamp("created_at").defaultNow(),
  // Snapshot of calculated time when booking (optional, mostly dynamic)
  estimatedWaitMinutes: integer("estimated_wait_minutes"), 
});
export const queueEntriesRelations = relations(queueEntries, ({ one }) => ({
  salon: one(salons, {
    fields: [queueEntries.salonId],
    references: [salons.id],
  }),
  customer: one(users, {
    fields: [queueEntries.customerId],
    references: [users.id],
  }),
  service: one(services, {
    fields: [queueEntries.serviceId],
    references: [services.id],
  }),
}));
export const insertQueueEntrySchema = createInsertSchema(queueEntries).omit({ 
  id: true, 
  tokenNumber: true, // Server assigns this
  status: true,
  createdAt: true,
  estimatedWaitMinutes: true
});
export type QueueEntry = typeof queueEntries.$inferSelect;
export type InsertQueueEntry = z.infer<typeof insertQueueEntrySchema>;
// === SUBSCRIPTIONS ===
export const subscriptions = pgTable("subscriptions", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  type: text("type", { enum: ["customer_basic", "customer_advance", "barber_monthly", "barber_yearly"] }).notNull(),
  startDate: timestamp("start_date").defaultNow(),
  endDate: timestamp("end_date").notNull(),
  isActive: boolean("is_active").default(true),
});
export const insertSubscriptionSchema = createInsertSchema(subscriptions).omit({ id: true, startDate: true, isActive: true });
export type Subscription = typeof subscriptions.$inferSelect;
export type InsertSubscription = z.infer<typeof insertSubscriptionSchema>;
// === TYPES FOR API ===
export type LoginRequest = { phone: string; otp: string };
export type CreateServiceRequest = InsertService;
export type JoinQueueRequest = { salonId: number; serviceId: number; customerId: number };
export type SalonWithDetails = Salon & {
  services: Service[];
  queueLength: number;
  estimatedWaitTime: number; // For the NEXT customer
};
export type QueueItemDetail = QueueEntry & {
  service: Service;
  customer: User;
  position: number;
  estimatedStartTime: string; // ISO string calculated on fetch
};
import { z } from "zod";
import { 
  insertUserSchema, 
  insertSalonSchema, 
  insertServiceSchema, 
  users, 
  salons, 
  services, 
  queueEntries,
  subscriptions
} from "./schema";

export const errorSchemas = {
  validation: z.object({
    message: z.string(),
    field: z.string().optional(),
  }),
  notFound: z.object({
    message: z.string(),
  }),
  internal: z.object({
    message: z.string(),
  }),
  unauthorized: z.object({
    message: z.string(),
  }),
};

export const api = {
  auth: {
    login: {
      method: 'POST' as const,
      path: '/api/auth/login',
      input: z.object({
        phone: z.string(),
        otp: z.string() // Mock OTP for now
      }),
      responses: {
        200: z.custom<typeof users.$inferSelect>(), // Returns user
        401: errorSchemas.unauthorized,
      },
    },
    register: {
      method: 'POST' as const,
      path: '/api/auth/register',
      input: insertUserSchema,
      responses: {
        201: z.custom<typeof users.$inferSelect>(),
        400: errorSchemas.validation,
      },
    },
    logout: {
      method: 'POST' as const,
      path: '/api/auth/logout',
      responses: {
        200: z.object({ message: z.string() }),
      }
    }
  },
  salons: {
    create: {
      method: 'POST' as const,
      path: '/api/salons',
      input: insertSalonSchema,
      responses: {
        201: z.custom<typeof salons.$inferSelect>(),
        400: errorSchemas.validation,
      },
    },
    getMySalon: { // For owner
      method: 'GET' as const,
      path: '/api/salons/me',
      responses: {
        200: z.custom<typeof salons.$inferSelect>(),
        404: errorSchemas.notFound,
      }
    },
    search: {
      method: 'GET' as const,
      path: '/api/salons/search',
      input: z.object({
        query: z.string().optional(),
      }).optional(),
      responses: {
        200: z.array(z.custom<typeof salons.$inferSelect>()),
      },
    },
    get: {
      method: 'GET' as const,
      path: '/api/salons/:id',
      responses: {
        200: z.custom<typeof salons.$inferSelect & { services: typeof services.$inferSelect[] }>(),
        404: errorSchemas.notFound,
      },
    },
    updateStatus: {
      method: 'PATCH' as const,
      path: '/api/salons/:id/status',
      input: z.object({
        isOpen: z.boolean().optional(),
        isOnBreak: z.boolean().optional(),
        action: z.enum(['open', 'close', 'break_start', 'break_end']).optional(),
      }),
      responses: {
        200: z.custom<typeof salons.$inferSelect>(),
      },
    },
    getQueueStatus: {
      method: 'GET' as const,
      path: '/api/salons/:id/queue-status',
      responses: {
        200: z.object({
          currentToken: z.number(),
          lastIssuedToken: z.number(),
          queueLength: z.number(),
          totalWaitTimeMinutes: z.number(),
        })
      }
    }
  },
  services: {
    create: {
      method: 'POST' as const,
      path: '/api/salons/:salonId/services',
      input: insertServiceSchema.omit({ salonId: true }),
      responses: {
        201: z.custom<typeof services.$inferSelect>(),
      }
    },
    list: {
      method: 'GET' as const,
      path: '/api/salons/:salonId/services',
      responses: {
        200: z.array(z.custom<typeof services.$inferSelect>()),
      }
    }
  },
  queue: {
    join: {
      method: 'POST' as const,
      path: '/api/queue/join',
      input: z.object({
        salonId: z.number(),
        serviceId: z.number(),
        customerId: z.number(),
      }),
      responses: {
        201: z.custom<typeof queueEntries.$inferSelect & { estimatedWaitMinutes: number, position: number }>(),
        400: errorSchemas.validation,
      }
    },
    list: { // For owner to see list
      method: 'GET' as const,
      path: '/api/salons/:salonId/queue',
      responses: {
        200: z.array(z.custom<typeof queueEntries.$inferSelect & { 
          customer: typeof users.$inferSelect,
          service: typeof services.$inferSelect 
        }>()),
      }
    },
    myQueue: { // For customer to see their active tokens
      method: 'GET' as const,
      path: '/api/queue/me',
      responses: {
        200: z.array(z.custom<typeof queueEntries.$inferSelect & { 
          salon: typeof salons.$inferSelect,
          service: typeof services.$inferSelect,
          position: number,
          estimatedWaitMinutes: number
        }>()),
      }
    },
    update: { // Next customer, cancel, etc.
      method: 'PATCH' as const,
      path: '/api/queue/:id',
      input: z.object({
        status: z.enum(['completed', 'cancelled']),
      }),
      responses: {
        200: z.custom<typeof queueEntries.$inferSelect>(),
      }
    },
    next: { // Special endpoint for owner to call "Next"
      method: 'POST' as const,
      path: '/api/salons/:salonId/queue/next',
      responses: {
        200: z.object({ message: z.string(), nextToken: z.number().nullable() }),
      }
    }
  },
  subscriptions: {
    subscribe: {
      method: 'POST' as const,
      path: '/api/subscriptions',
      input: z.object({
        userId: z.number(),
        type: z.enum(["customer_basic", "customer_advance", "barber_monthly", "barber_yearly"]),
      }),
      responses: {
        201: z.custom<typeof subscriptions.$inferSelect>(),
      }
    }
  }
};

export function buildUrl(path: string, params?: Record<string, string | number>): string {
  let url = path;
  if (params) {
    Object.entries(params).forEach(([key, value]) => {
      if (url.includes(`:${key}`)) {
        url = url.replace(`:${key}`, String(value));
      }
    });
  }
  return url;
}
## Packages
framer-motion | For smooth page transitions and micro-interactions
date-fns | For time calculations and formatting
lucide-react | For all UI icons (already in base, but emphasizing usage)

## Notes
Tailwind Config - extend fontFamily:
fontFamily: {
  display: ["var(--font-display)"],
  body: ["var(--font-body)"],
}

@import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --font-display: 'Outfit', sans-serif;
  --font-body: 'Plus Jakarta Sans', sans-serif;

  /* Fresh, clean, professional palette */
  --background: 210 40% 98%;
  --foreground: 222 47% 11%;

  --primary: 262 83% 58%; /* Vibrant Purple */
  --primary-foreground: 210 40% 98%;

  --secondary: 210 40% 96%;
  --secondary-foreground: 222 47% 11%;

  --muted: 210 40% 96%;
  --muted-foreground: 215 16% 47%;

  --accent: 199 89% 48%; /* Blue/Cyan accent for contrast */
  --accent-foreground: 210 40% 98%;

  --destructive: 0 84% 60%;
  --destructive-foreground: 210 40% 98%;

  --border: 214 32% 91%;
  --input: 214 32% 91%;
  --ring: 262 83% 58%;

  --radius: 1rem;
  
  /* Status Colors */
  --success: 142 71% 45%;
  --warning: 38 92% 50%;
}

.dark {
  --background: 222 47% 11%;
  --foreground: 210 40% 98%;

  --primary: 263 70% 50%;
  --primary-foreground: 210 40% 98%;

  --secondary: 217 33% 17%;
  --secondary-foreground: 210 40% 98%;

  --muted: 217 33% 17%;
  --muted-foreground: 215 20% 65%;

  --accent: 199 89% 48%;
  --accent-foreground: 210 40% 98%;

  --destructive: 0 62% 30%;
  --destructive-foreground: 210 40% 98%;

  --border: 217 33% 17%;
  --input: 217 33% 17%;
  --ring: 263 70% 50%;
}

@layer base {
  body {
    @apply bg-background text-foreground antialiased selection:bg-primary/20;
    font-family: var(--font-body);
  }

  h1, h2, h3, h4, h5, h6 {
    font-family: var(--font-display);
    @apply font-bold tracking-tight text-foreground;
  }
}

@layer components {
  .btn-primary {
    @apply bg-primary text-primary-foreground hover:bg-primary/90 shadow-lg shadow-primary/25 hover:shadow-xl hover:shadow-primary/30 transition-all duration-300 active:scale-[0.98] font-semibold px-6 py-3 rounded-xl;
  }
  
  .btn-secondary {
    @apply bg-white text-foreground border border-border hover:bg-secondary/50 shadow-sm hover:shadow transition-all duration-300 active:scale-[0.98] font-medium px-6 py-3 rounded-xl;
  }

  .card-hover {
    @apply bg-white border border-border/60 shadow-sm hover:shadow-lg hover:border-primary/20 transition-all duration-300 rounded-2xl;
  }

  .input-modern {
    @apply w-full px-4 py-3 rounded-xl bg-white border border-input focus:outline-none focus:ring-2 focus:ring-primary/20 focus:border-primary transition-all duration-200;
  }
}

/* Custom Scrollbar */
::-webkit-scrollbar {
  width: 8px;
}
::-webkit-scrollbar-track {
  background: transparent;
}
::-webkit-scrollbar-thumb {
  background: hsl(var(--muted-foreground) / 0.2);
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
  background: hsl(var(--muted-foreground) / 0.4);
}

import { useMutation, useQueryClient } from "@tanstack/react-query";
import { api, type LoginRequest, type InsertUser } from "@shared/routes";
import { useLocation } from "wouter";
import { useToast } from "@/hooks/use-toast";

// Simple auth state management using localStorage for this demo
// In a real app, this would be handled by HTTP-only cookies and a /me endpoint
const USER_KEY = "salon_user";

export function useAuth() {
  const queryClient = useQueryClient();
  const [location, setLocation] = useLocation();
  const { toast } = useToast();

  const user = (() => {
    try {
      const stored = localStorage.getItem(USER_KEY);
      return stored ? JSON.parse(stored) : null;
    } catch {
      return null;
    }
  })();

  const loginMutation = useMutation({
    mutationFn: async (data: LoginRequest) => {
      const res = await fetch(api.auth.login.path, {
        method: api.auth.login.method,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      
      if (!res.ok) throw new Error("Login failed");
      return api.auth.login.responses[200].parse(await res.json());
    },
    onSuccess: (data) => {
      localStorage.setItem(USER_KEY, JSON.stringify(data));
      queryClient.setQueryData(["user"], data);
      toast({ title: "Welcome back!", description: `Logged in as ${data.name}` });
      
      // Redirect based on role
      if (data.role === "barber") {
        setLocation("/barber");
      } else {
        setLocation("/customer");
      }
    },
    onError: () => {
      toast({ variant: "destructive", title: "Login failed", description: "Invalid credentials" });
    }
  });

  const registerMutation = useMutation({
    mutationFn: async (data: InsertUser) => {
      const res = await fetch(api.auth.register.path, {
        method: api.auth.register.method,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      
      if (!res.ok) throw new Error("Registration failed");
      return api.auth.register.responses[201].parse(await res.json());
    },
    onSuccess: (data) => {
      localStorage.setItem(USER_KEY, JSON.stringify(data));
      queryClient.setQueryData(["user"], data);
      toast({ title: "Account created!", description: "Welcome to QueuePro" });
      
      if (data.role === "barber") {
        setLocation("/barber/setup"); // First time setup
      } else {
        setLocation("/customer");
      }
    },
    onError: () => {
      toast({ variant: "destructive", title: "Error", description: "Could not create account" });
    }
  });

  const logout = () => {
    localStorage.removeItem(USER_KEY);
    queryClient.setQueryData(["user"], null);
    setLocation("/");
    toast({ title: "Logged out", description: "See you soon!" });
  };

  return {
    user,
    login: loginMutation.mutate,
    isLoggingIn: loginMutation.isPending,
    register: registerMutation.mutate,
    isRegistering: registerMutation.isPending,
    logout
  };
}
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { api, buildUrl, type InsertSalon } from "@shared/routes";
import { useToast } from "@/hooks/use-toast";

export function useSalons(searchQuery?: string) {
  return useQuery({
    queryKey: [api.salons.search.path, searchQuery],
    queryFn: async () => {
      const url = searchQuery 
        ? `${api.salons.search.path}?query=${encodeURIComponent(searchQuery)}`
        : api.salons.search.path;
      
      const res = await fetch(url);
      if (!res.ok) throw new Error("Failed to fetch salons");
      return api.salons.search.responses[200].parse(await res.json());
    },
  });
}

export function useSalon(id: number) {
  return useQuery({
    queryKey: [api.salons.get.path, id],
    enabled: !!id,
    queryFn: async () => {
      const url = buildUrl(api.salons.get.path, { id });
      const res = await fetch(url);
      if (!res.ok) throw new Error("Failed to fetch salon");
      return api.salons.get.responses[200].parse(await res.json());
    },
  });
}

export function useMySalon() {
  return useQuery({
    queryKey: [api.salons.getMySalon.path],
    retry: false,
    queryFn: async () => {
      const res = await fetch(api.salons.getMySalon.path);
      if (res.status === 404) return null;
      if (!res.ok) throw new Error("Failed to fetch my salon");
      return api.salons.getMySalon.responses[200].parse(await res.json());
    },
  });
}

export function useCreateSalon() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (data: InsertSalon) => {
      const res = await fetch(api.salons.create.path, {
        method: api.salons.create.method,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      if (!res.ok) throw new Error("Failed to create salon");
      return api.salons.create.responses[201].parse(await res.json());
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [api.salons.getMySalon.path] });
      toast({ title: "Success", description: "Salon created successfully!" });
    },
    onError: () => {
      toast({ variant: "destructive", title: "Error", description: "Failed to create salon" });
    }
  });
}

export function useUpdateSalonStatus() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async ({ id, ...data }: { id: number, action: 'open' | 'close' | 'break_start' | 'break_end' }) => {
      const url = buildUrl(api.salons.updateStatus.path, { id });
      const res = await fetch(url, {
        method: api.salons.updateStatus.method,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      if (!res.ok) throw new Error("Failed to update status");
      return api.salons.updateStatus.responses[200].parse(await res.json());
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [api.salons.getMySalon.path] });
      toast({ title: "Status Updated", description: "Salon status changed successfully." });
    },
  });
}

export function useSalonQueueStatus(id: number) {
  return useQuery({
    queryKey: [api.salons.getQueueStatus.path, id],
    enabled: !!id,
    refetchInterval: 10000, // Poll every 10s for updates
    queryFn: async () => {
      const url = buildUrl(api.salons.getQueueStatus.path, { id });
      const res = await fetch(url);import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { api, buildUrl, type InsertSalon } from "@shared/routes";
import { useToast } from "@/hooks/use-toast";

export function useSalons(searchQuery?: string) {
  return useQuery({
    queryKey: [api.salons.search.path, searchQuery],
    queryFn: async () => {
      const url = searchQuery 
        ? `${api.salons.search.path}?query=${encodeURIComponent(searchQuery)}`
        : api.salons.search.path;
      
      const res = await fetch(url);
      if (!res.ok) throw new Error("Failed to fetch salons");
      return api.salons.search.responses[200].parse(await res.json());
    },
  });
}

export function useSalon(id: number) {
  return useQuery({
    queryKey: [api.salons.get.path, id],
    enabled: !!id,
    queryFn: async () => {
      const url = buildUrl(api.salons.get.path, { id });
      const res = await fetch(url);
      if (!res.ok) throw new Error("Failed to fetch salon");
      return api.salons.get.responses[200].parse(await res.json());
    },
  });
}

export function useMySalon() {
  return useQuery({
    queryKey: [api.salons.getMySalon.path],
    retry: false,
    queryFn: async () => {
      const res = await fetch(api.salons.getMySalon.path);
      if (res.status === 404) return null;
      if (!res.ok) throw new Error("Failed to fetch my salon");
      return api.salons.getMySalon.responses[200].parse(await res.json());
    },
  });
}

export function useCreateSalon() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (data: InsertSalon) => {
      const res = await fetch(api.salons.create.path, {
        method: api.salons.create.method,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      if (!res.ok) throw new Error("Failed to create salon");
      return api.salons.create.responses[201].parse(await res.json());
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [api.salons.getMySalon.path] });
      toast({ title: "Success", description: "Salon created successfully!" });
    },
    onError: () => {
      toast({ variant: "destructive", title: "Error", description: "Failed to create salon" });
    }
  });
}

export function useUpdateSalonStatus() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async ({ id, ...data }: { id: number, action: 'open' | 'close' | 'break_start' | 'break_end' }) => {
      const url = buildUrl(api.salons.updateStatus.path, { id });
      const res = await fetch(url, {
        method: api.salons.updateStatus.method,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      if (!res.ok) throw new Error("Failed to update status");
      return api.salons.updateStatus.responses[200].parse(await res.json());
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [api.salons.getMySalon.path] });
      toast({ title: "Status Updated", description: "Salon status changed successfully." });
    },
  });
}

export function useSalonQueueStatus(id: number) {
  return useQuery({
    queryKey: [api.salons.getQueueStatus.path, id],
    enabled: !!id,
    refetchInterval: 10000, // Poll every 10s for updates
    queryFn: async () => {
      const url = buildUrl(api.salons.getQueueStatus.path, { id });
      const res = await fetch(url);
      if (!res.ok) throw new Error("Failed to fetch queue status");
      return api.salons.getQueueStatus.responses[200].parse(await res.json());
    },
  });
}
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { api, buildUrl, type InsertSalon } from "@shared/routes";
import { useToast } from "@/hooks/use-toast";

export function useSalons(searchQuery?: string) {
  return useQuery({
    queryKey: [api.salons.search.path, searchQuery],
    queryFn: async () => {
      const url = searchQuery 
        ? `${api.salons.search.path}?query=${encodeURIComponent(searchQuery)}`
        : api.salons.search.path;
      
      const res = await fetch(url);
      if (!res.ok) throw new Error("Failed to fetch salons");
      return api.salons.search.responses[200].parse(await res.json());
    },
  });
}

export function useSalon(id: number) {
  return useQuery({
    queryKey: [api.salons.get.path, id],
    enabled: !!id,
    queryFn: async () => {
      const url = buildUrl(api.salons.get.path, { id });
      const res = await fetch(url);
      if (!res.ok) throw new Error("Failed to fetch salon");
      return api.salons.get.responses[200].parse(await res.json());
    },
  });
}

export function useMySalon() {
  return useQuery({
    queryKey: [api.salons.getMySalon.path],
    retry: false,
    queryFn: async () => {
      const res = await fetch(api.salons.getMySalon.path);
      if (res.status === 404) return null;
      if (!res.ok) throw new Error("Failed to fetch my salon");
      return api.salons.getMySalon.responses[200].parse(await res.json());
    },
  });
}

export function useCreateSalon() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (data: InsertSalon) => {
      const res = await fetch(api.salons.create.path, {
        method: api.salons.create.method,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      if (!res.ok) throw new Error("Failed to create salon");
      return api.salons.create.responses[201].parse(await res.json());
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [api.salons.getMySalon.path] });
      toast({ title: "Success", description: "Salon created successfully!" });
    },
    onError: () => {
      toast({ variant: "destructive", title: "Error", description: "Failed to create salon" });
    }
  });
}

export function useUpdateSalonStatus() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async ({ id, ...data }: { id: number, action: 'open' | 'close' | 'break_start' | 'break_end' }) => {
      const url = buildUrl(api.salons.updateStatus.path, { id });
      const res = await fetch(url, {
        method: api.salons.updateStatus.method,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      if (!res.ok) throw new Error("Failed to update status");
      return api.salons.updateStatus.responses[200].parse(await res.json());
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [api.salons.getMySalon.path] });
      toast({ title: "Status Updated", description: "Salon status changed successfully." });
    },
  });
}

export function useSalonQueueStatus(id: number) {
  return useQuery({
    queryKey: [api.salons.getQueueStatus.path, id],
    enabled: !!id,
    refetchInterval: 10000, // Poll every 10s for updates
    queryFn: async () => {
      const url = buildUrl(api.salons.getQueueStatus.path, { id });
      const res = await fetch(url);
      if (!res.ok) throw new Error("Failed to fetch queue status");
      return api.salons.getQueueStatus.responses[200].parse(await res.json());
    },
  });
}
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { api, buildUrl, type JoinQueueRequest } from "@shared/routes";
import { useToast } from "@/hooks/use-toast";

export function useJoinQueue() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (data: JoinQueueRequest) => {
      const res = await fetch(api.queue.join.path, {
        method: api.queue.join.method,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      if (!res.ok) throw new Error("Failed to join queue");
      return api.queue.join.responses[201].parse(await res.json());
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [api.queue.myQueue.path] });
      toast({ title: "Success!", description: "You have been added to the queue." });
    },
    onError: () => {
      toast({ variant: "destructive", title: "Error", description: "Failed to join queue" });
    }
  });
}

export function useMyQueue() {
  return useQuery({
    queryKey: [api.queue.myQueue.path],
    refetchInterval: 5000, // Frequent updates for customers waiting
    queryFn: async () => {
      const res = await fetch(api.queue.myQueue.path);
      if (!res.ok) throw new Error("Failed to fetch my queue");
      return api.queue.myQueue.responses[200].parse(await res.json());
    },
  });
}

export function useSalonQueue(salonId: number) {
  return useQuery({
    queryKey: [api.queue.list.path, salonId],
    enabled: !!salonId,
    refetchInterval: 5000,
    queryFn: async () => {
      const url = buildUrl(api.queue.list.path, { salonId });
      const res = await fetch(url);
      if (!res.ok) throw new Error("Failed to fetch queue");
      return api.queue.list.responses[200].parse(await res.json());
    },
  });
}

export function useNextCustomer() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (salonId: number) => {
      const url = buildUrl(api.queue.next.path, { salonId });
      const res = await fetch(url, {
        method: api.queue.next.method,
      });
      if (!res.ok) throw new Error("Failed to call next customer");
      return api.queue.next.responses[200].parse(await res.json());
    },
    onSuccess: (_, salonId) => {
      queryClient.invalidateQueries({ queryKey: [api.queue.list.path, salonId] });
      queryClient.invalidateQueries({ queryKey: [api.salons.getQueueStatus.path, salonId] });
      toast({ title: "Next Customer", description: "Called next customer in line." });
    },
  });
}

export function useUpdateQueueItem() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async ({ id, status }: { id: number, status: 'completed' | 'cancelled' }) => {
      const url = buildUrl(api.queue.update.path, { id });
      const res = await fetch(url, {
        method: api.queue.update.method,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ status }),
      });
      if (!res.ok) throw new Error("Failed to update queue item");
      return api.queue.update.responses[200].parse(await res.json());
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [api.queue.myQueue.path] });
      queryClient.invalidateQueries({ queryKey: [api.queue.list.path] }); // Covers owner view too broadly, but safe
      toast({ title: "Updated", description: "Queue status updated." });
    },
  });
}
import { drizzle } from "drizzle-orm/node-postgres";
import pg from "pg";
import * as schema from "@shared/schema";

const { Pool } = pg;

if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?",
  );
}

export const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle(pool, { schema });

import { type User, type InsertUser } from "@shared/schema";
import { randomUUID } from "crypto";
// modify the interface with any CRUD methods
// you might need
import { db } from "./db";
import { 
  users, salons, services, queueEntries, subscriptions,
  type User, type InsertUser, 
  type Salon, type InsertSalon,
  type Service, type InsertService,
  type QueueEntry, type InsertQueueEntry,
  type Subscription, type InsertSubscription
} from "@shared/schema";
import { eq, and, gt, desc, asc, sql } from "drizzle-orm";
export interface IStorage {
  getUser(id: string): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  // User
  createUser(user: InsertUser): Promise<User>;
  getUserByPhone(phone: string): Promise<User | undefined>;
  getUser(id: number): Promise<User | undefined>;
  // Salon
  createSalon(salon: InsertSalon): Promise<Salon>;
  getSalonByOwner(ownerId: number): Promise<Salon | undefined>;
  getSalon(id: number): Promise<Salon | undefined>;
  searchSalons(query?: string): Promise<Salon[]>;
  updateSalonStatus(id: number, status: Partial<Salon>): Promise<Salon>;
  resetSalonTokens(id: number): Promise<void>;
  // Services
  createService(service: InsertService): Promise<Service>;
  getSalonServices(salonId: number): Promise<Service[]>;
  getService(id: number): Promise<Service | undefined>;
  // Queue
  addToQueue(entry: InsertQueueEntry): Promise<QueueEntry>;
  getSalonQueue(salonId: number): Promise<(QueueEntry & { customer: User; service: Service })[]>;
  getCustomerActiveQueueEntries(customerId: number): Promise<(QueueEntry & { salon: Salon; service: Service })[]>;
  updateQueueStatus(id: number, status: "completed" | "cancelled"): Promise<QueueEntry>;
  getNextInQueue(salonId: number): Promise<QueueEntry | undefined>;
  getQueueEntry(id: number): Promise<QueueEntry | undefined>;
  
  // Subscription
  createSubscription(sub: InsertSubscription): Promise<Subscription>;
}
export class MemStorage implements IStorage {
  private users: Map<string, User>;
  constructor() {
    this.users = new Map();
export class DatabaseStorage implements IStorage {
  // User Operations
  async createUser(user: InsertUser): Promise<User> {
    const [newUser] = await db.insert(users).values(user).returning();
    return newUser;
  }
  async getUser(id: string): Promise<User | undefined> {
    return this.users.get(id);
  async getUserByPhone(phone: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.phone, phone));
    return user;
  }
  async getUserByUsername(username: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(
      (user) => user.username === username,
    );
  async getUser(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }
  async createUser(insertUser: InsertUser): Promise<User> {
    const id = randomUUID();
    const user: User = { ...insertUser, id };
    this.users.set(id, user);
    return user;
  // Salon Operations
  async createSalon(salon: InsertSalon): Promise<Salon> {
    const [newSalon] = await db.insert(salons).values(salon).returning();
    return newSalon;
  }
  async getSalonByOwner(ownerId: number): Promise<Salon | undefined> {
    const [salon] = await db.select().from(salons).where(eq(salons.ownerId, ownerId));
    return salon;
  }
  async getSalon(id: number): Promise<Salon | undefined> {
    const [salon] = await db.select().from(salons).where(eq(salons.id, id));
    return salon;
  }
  async searchSalons(query?: string): Promise<Salon[]> {
    if (!query) {
      return await db.select().from(salons);
    }
    return await db.select().from(salons).where(sql`${salons.name} ILIKE ${`%${query}%`}`);
  }
  async updateSalonStatus(id: number, status: Partial<Salon>): Promise<Salon> {
    const [updated] = await db.update(salons).set(status).where(eq(salons.id, id)).returning();
    return updated;
  }
  async resetSalonTokens(id: number): Promise<void> {
    await db.update(salons)
      .set({ currentToken: 0, lastIssuedToken: 0, lastTokenReset: sql`CURRENT_DATE` })
      .where(eq(salons.id, id));
  }
  // Services Operations
  async createService(service: InsertService): Promise<Service> {
    const [newService] = await db.insert(services).values(service).returning();
    return newService;
  }
  async getSalonServices(salonId: number): Promise<Service[]> {
    return await db.select().from(services).where(eq(services.salonId, salonId));
  }
  async getService(id: number): Promise<Service | undefined> {
    const [service] = await db.select().from(services).where(eq(services.id, id));
    return service;
  }
  // Queue Operations
  async addToQueue(entry: InsertQueueEntry): Promise<QueueEntry> {
    const [newEntry] = await db.insert(queueEntries).values(entry).returning();
    return newEntry;
  }
  async getSalonQueue(salonId: number): Promise<(QueueEntry & { customer: User; service: Service })[]> {
    return await db.query.queueEntries.findMany({
      where: and(
        eq(queueEntries.salonId, salonId),
        eq(queueEntries.status, "waiting")
      ),
      with: {
        customer: true,
        service: true,
      },
      orderBy: [asc(queueEntries.tokenNumber)]
    });
  }
  async getCustomerActiveQueueEntries(customerId: number): Promise<(QueueEntry & { salon: Salon; service: Service })[]> {
    return await db.query.queueEntries.findMany({
      where: and(
        eq(queueEntries.customerId, customerId),
        eq(queueEntries.status, "waiting")
      ),
      with: {
        salon: true,
        service: true
      }
    });
  }
  async updateQueueStatus(id: number, status: "completed" | "cancelled"): Promise<QueueEntry> {
    const [updated] = await db.update(queueEntries)
      .set({ status })
      .where(eq(queueEntries.id, id))
      .returning();
    return updated;
  }
  async getNextInQueue(salonId: number): Promise<QueueEntry | undefined> {
    const [next] = await db.select()
      .from(queueEntries)
      .where(and(eq(queueEntries.salonId, salonId), eq(queueEntries.status, "waiting")))
      .orderBy(asc(queueEntries.tokenNumber))
      .limit(1);
    return next;
  }
  
  async getQueueEntry(id: number): Promise<QueueEntry | undefined> {
    const [entry] = await db.select().from(queueEntries).where(eq(queueEntries.id, id));
    return entry;
  }
  // Subscription Operations
  async createSubscription(sub: InsertSubscription): Promise<Subscription> {
    const [newSub] = await db.insert(subscriptions).values(sub).returning();
    return newSub;
  }
}
export const storage = new MemStorage();
export const storage = new DatabaseStorage();
      if (!res.ok) throw new Error("Failed to fetch queue status");
      return api.salons.getQueueStatus.responses[200].parse(await res.json());
    },
  });
}
import type { Express } from "express";
import { createServer, type Server } from "http";
import type { Server } from "http";
import { storage } from "./storage";
import { api, errorSchemas } from "@shared/routes";
import { z } from "zod";
import { users } from "@shared/schema";
export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  // put application routes here
  // prefix all routes with /api
  // use storage to perform CRUD operations on the storage interface
  // e.g. storage.insertUser(user) or storage.getUserByUsername(username)
  // === AUTH ===
  app.post(api.auth.login.path, async (req, res) => {
    // Simple mock auth
    const { phone, otp } = req.body;
    if (otp !== "1234") {
      return res.status(401).json({ message: "Invalid OTP" });
    }
    const user = await storage.getUserByPhone(phone);
    if (!user) {
      return res.status(401).json({ message: "User not found. Please register." });
    }
    // In a real app, we'd set a session here. For now, we return the user and client stores it.
    res.json(user);
  });
  app.post(api.auth.register.path, async (req, res) => {
    try {
      const input = api.auth.register.input.parse(req.body);
      const user = await storage.createUser(input);
      res.status(201).json(user);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });
  // === SALONS ===
  app.post(api.salons.create.path, async (req, res) => {
    try {
      const input = api.salons.create.input.parse(req.body);
      const salon = await storage.createSalon(input);
      res.status(201).json(salon);
    } catch (err) {
      res.status(400).json({ message: "Invalid input" });
    }
  });
  app.get(api.salons.getMySalon.path, async (req, res) => {
    // Requires ownerId in query or header in a real app, simulating with query param 'userId' for MVP simplicity
    // But since the API definition doesn't have it, we'll assume the frontend passes it or we mocked session.
    // For this MVP, let's pass userId as a query param to identifying the owner for this specific route.
    // Wait, standard practice is session. Let's assume the client passes X-User-Id header.
    const userId = Number(req.headers['x-user-id']);
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const salon = await storage.getSalonByOwner(userId);
    if (!salon) return res.status(404).json({ message: "Salon not found" });
    res.json(salon);
  });
  app.get(api.salons.search.path, async (req, res) => {
    const query = req.query.query as string | undefined;
    const salons = await storage.searchSalons(query);
    res.json(salons);
  });
  app.get(api.salons.get.path, async (req, res) => {
    const salonId = Number(req.params.id);
    const salon = await storage.getSalon(salonId);
    if (!salon) return res.status(404).json({ message: "Salon not found" });
    const services = await storage.getSalonServices(salonId);
    res.json({ ...salon, services });
  });
  app.patch(api.salons.updateStatus.path, async (req, res) => {
    const salonId = Number(req.params.id);
    const { action, ...updates } = req.body;
    
    let finalUpdates = { ...updates };
    
    // Handle convenience actions
    if (action === 'open') {
      finalUpdates = { isOpen: true, isOnBreak: false };
      // Check if we need to reset token if it's a new day? 
      // Simplified: We assume daily reset happens via a separate check or manually.
      // But let's check date.
      const salon = await storage.getSalon(salonId);
      if (salon) {
        const today = new Date().toISOString().split('T')[0];
        if (salon.lastTokenReset !== today) {
           await storage.resetSalonTokens(salonId);
        }
      }
    } else if (action === 'close') {
      finalUpdates = { isOpen: false, isOnBreak: false };
    } else if (action === 'break_start') {
      finalUpdates = { isOnBreak: true, breakStartTime: new Date() };
    } else if (action === 'break_end') {
      finalUpdates = { isOnBreak: false, breakStartTime: null };
    }
    const updated = await storage.updateSalonStatus(salonId, finalUpdates);
    res.json(updated);
  });
  app.get(api.salons.getQueueStatus.path, async (req, res) => {
    const salonId = Number(req.params.id);
    const salon = await storage.getSalon(salonId);
    if (!salon) return res.status(404).json({ message: "Salon not found" });
    
    const queue = await storage.getSalonQueue(salonId);
    
    // Calculate total wait time
    let totalWaitTime = 0;
    queue.forEach(item => {
      totalWaitTime += item.service.durationMinutes;
    });
    res.json({
      currentToken: salon.currentToken || 0,
      lastIssuedToken: salon.lastIssuedToken || 0,
      queueLength: queue.length,
      totalWaitTimeMinutes: totalWaitTime
    });
  });
  // === SERVICES ===
  app.post(api.services.create.path, async (req, res) => {
    const salonId = Number(req.params.salonId);
    const input = api.services.create.input.parse({ ...req.body, salonId }); // Manually inject salonId from param if needed or body
    // Actually the schema for input omits salonId, so we need to add it back for storage call
    // But route def says input is omit salonId.
    // So we reconstruct.
    const service = await storage.createService({ ...input, salonId });
    res.status(201).json(service);
  });
  app.get(api.services.list.path, async (req, res) => {
    const salonId = Number(req.params.salonId);
    const services = await storage.getSalonServices(salonId);
    res.json(services);
  });
  // === QUEUE ===
  app.post(api.queue.join.path, async (req, res) => {
    const { salonId, serviceId, customerId } = req.body;
    
    const salon = await storage.getSalon(salonId);
    if (!salon) return res.status(404).json({ message: "Salon not found" });
    if (!salon.isOpen) return res.status(400).json({ message: "Salon is closed" });
    // Check if user already in queue? Simplified: allow multiple for now.
    // Assign token
    const newTokenNumber = (salon.lastIssuedToken || 0) + 1;
    
    // Calculate estimated wait time
    const currentQueue = await storage.getSalonQueue(salonId);
    let waitTime = 0;
    currentQueue.forEach(q => waitTime += q.service.durationMinutes);
    
    // If salon is on break, add break buffer? (Simplification: ignore break duration for calculation for now, just service time)
    const entry = await storage.addToQueue({
      salonId,
      serviceId,
      customerId,
      tokenNumber: newTokenNumber,
      estimatedWaitMinutes: waitTime,
      status: "waiting",
      // created_at is default
    });
    // Update salon last token
    await storage.updateSalonStatus(salonId, { lastIssuedToken: newTokenNumber });
    res.status(201).json({ ...entry, position: currentQueue.length + 1, estimatedWaitMinutes: waitTime });
  });
  app.get(api.queue.list.path, async (req, res) => {
    const salonId = Number(req.params.salonId);
    const queue = await storage.getSalonQueue(salonId);
    res.json(queue);
  });
  app.get(api.queue.myQueue.path, async (req, res) => {
     const userId = Number(req.headers['x-user-id']);
     if (!userId) return res.status(401).json({ message: "Unauthorized" });
     
     const entries = await storage.getCustomerActiveQueueEntries(userId);
     
     // Enhance with dynamic calculation
     const enhancedEntries = await Promise.all(entries.map(async (entry) => {
       // Get fresh queue state for this salon
       const salonQueue = await storage.getSalonQueue(entry.salonId);
       // Find position
       const position = salonQueue.findIndex(q => q.id === entry.id) + 1; // 1-based
       
       // Calculate wait time: sum of all people BEFORE this entry
       let waitTime = 0;
       for (const q of salonQueue) {
         if (q.id === entry.id) break;
         waitTime += q.service.durationMinutes;
       }
       
       return {
         ...entry,
         position,
         estimatedWaitMinutes: waitTime
       };
     }));
     res.json(enhancedEntries);
  });
  app.post(api.queue.next.path, async (req, res) => {
    const salonId = Number(req.params.salonId);
    const salon = await storage.getSalon(salonId);
    if (!salon) return res.status(404).json({ message: "Salon not found" });
    // Find current waiting token with lowest number
    const nextItem = await storage.getNextInQueue(salonId);
    
    if (nextItem) {
      // Mark as completed (or should we mark the PREVIOUS one as completed? 
      // "Next Customer" usually means: Finish current, start next.
      // So we should find the one "in_progress" (if we had that state) and finish it.
      // For MVP "Next" -> Marks the *current active* token as done (if any), and implicitly starts the next?
      // Simplified: We just remove the top of the queue (mark completed).
      await storage.updateQueueStatus(nextItem.id, "completed");
      
      // Update salon current token
      await storage.updateSalonStatus(salonId, { currentToken: nextItem.tokenNumber });
      
      // Get the NEW next token to return
      const newNext = await storage.getNextInQueue(salonId);
      
      res.json({ message: "Queue advanced", nextToken: newNext?.tokenNumber || null });
    } else {
      res.json({ message: "Queue is empty", nextToken: null });
    }
  });
  app.patch(api.queue.update.path, async (req, res) => {
    const id = Number(req.params.id);
    const { status } = req.body;
    const updated = await storage.updateQueueStatus(id, status);
    res.json(updated);
  });
  // === SUBSCRIPTIONS ===
  app.post(api.subscriptions.subscribe.path, async (req, res) => {
    const input = api.subscriptions.subscribe.input.parse(req.body);
    // Mock subscription logic: just create it
    const sub = await storage.createSubscription({
      userId: input.userId,
      type: input.type,
      endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // +30 days mock
    });
    res.status(201).json(sub);
  });
  return httpServer;
}import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { api, buildUrl, type InsertService } from "@shared/routes";
import { useToast } from "@/hooks/use-toast";

export function useServices(salonId: number) {
  return useQuery({
    queryKey: [api.services.list.path, salonId],
    enabled: !!salonId,
    queryFn: async () => {
      const url = buildUrl(api.services.list.path, { salonId });
      const res = await fetch(url);
      if (!res.ok) throw new Error("Failed to fetch services");
      return api.services.list.responses[200].parse(await res.json());
    },
  });
}

export function useCreateService() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async ({ salonId, ...data }: InsertService & { salonId: number }) => {
      const url = buildUrl(api.services.create.path, { salonId });
      const res = await fetch(url, {
        method: api.services.create.method,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      if (!res.ok) throw new Error("Failed to create service");
      return api.services.create.responses[201].parse(await res.json());
    },
    onSuccess: (_, vars) => {
      queryClient.invalidateQueries({ queryKey: [api.services.list.path, vars.salonId] });
      toast({ title: "Service Added", description: "New service created successfully." });
    },
  });
}
import { Link, useLocation } from "wouter";
import { Home, Ticket, User, Scissors } from "lucide-react";
import { cn } from "@/lib/utils";

interface BottomNavProps {
  role: "customer" | "barber";
}

export function BottomNav({ role }: BottomNavProps) {
  const [location] = useLocation();

  const customerLinks = [
    { href: "/customer", icon: Home, label: "Home" },
    { href: "/customer/my-tokens", icon: Ticket, label: "My Tokens" },
    { href: "/customer/profile", icon: User, label: "Profile" },
  ];

  const barberLinks = [
    { href: "/barber", icon: Home, label: "Dashboard" },
    { href: "/barber/queue", icon: Scissors, label: "Queue" },
    { href: "/barber/profile", icon: User, label: "Profile" },
  ];

  const links = role === "customer" ? customerLinks : barberLinks;

  return (
    <nav className="fixed bottom-0 left-0 right-0 bg-white border-t border-border z-50 safe-area-bottom pb-safe">
      <div className="flex justify-around items-center h-16">
        {links.map(({ href, icon: Icon, label }) => {
          const isActive = location === href;
          return (
            <Link key={href} href={href} className="w-full h-full">
              <div
                className={cn(
                  "flex flex-col items-center justify-center h-full w-full cursor-pointer transition-colors duration-200",
                  isActive ? "text-primary" : "text-muted-foreground hover:text-foreground"
                )}
              >
                <Icon className={cn("w-6 h-6 mb-1", isActive && "fill-current/10")} />
                <span className="text-[10px] font-medium">{label}</span>
              </div>
            </Link>
          );
        })}
      </div>
    </nav>
  );
}
import { LogOut } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import { Button } from "@/components/ui/button";

interface HeaderProps {
  title: string;
  subtitle?: string;
  showLogout?: boolean;
}

export function Header({ title, subtitle, showLogout = true }: HeaderProps) {
  const { logout } = useAuth();

  return (
    <header className="sticky top-0 z-40 bg-white/80 backdrop-blur-md border-b border-border">
      <div className="max-w-md mx-auto px-4 py-4 flex items-center justify-between">
        <div>
          <h1 className="text-xl font-bold text-foreground font-display">{title}</h1>
          {subtitle && <p className="text-sm text-muted-foreground">{subtitle}</p>}
        </div>
        {showLogout && (
          <Button variant="ghost" size="icon" onClick={logout} className="text-muted-foreground hover:text-destructive">
            <LogOut className="w-5 h-5" />
          </Button>
        )}
      </div>
    </header>
  );
}
import { LogOut } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import { Button } from "@/components/ui/button";

interface HeaderProps {
  title: string;
  subtitle?: string;
  showLogout?: boolean;
}

export function Header({ title, subtitle, showLogout = true }: HeaderProps) {
  const { logout } = useAuth();

  return (
    <header className="sticky top-0 z-40 bg-white/80 backdrop-blur-md border-b border-border">
      <div className="max-w-md mx-auto px-4 py-4 flex items-center justify-between">
        <div>
          <h1 className="text-xl font-bold text-foreground font-display">{title}</h1>
          {subtitle && <p className="text-sm text-muted-foreground">{subtitle}</p>}
        </div>
        {showLogout && (
          <Button variant="ghost" size="icon" onClick={logout} className="text-muted-foreground hover:text-destructive">
            <LogOut className="w-5 h-5" />
          </Button>
        )}
      </div>
    </header>
  );
}
import { storage } from "./storage";
import { db } from "./db";
import { users, salons, services, queueEntries } from "@shared/schema";

async function seed() {
  console.log("Seeding database...");

  // Check if data exists
  const existingUsers = await db.select().from(users).limit(1);
  if (existingUsers.length > 0) {
    console.log("Database already seeded.");
    return;
  }

  // Create Customers
  const cust1 = await storage.createUser({
    name: "Rahul Kumar",
    phone: "9876543210",
    role: "customer",
    location: "Mumbai"
  });
  
  const cust2 = await storage.createUser({
    name: "Amit Singh",
    phone: "9876543211",
    role: "customer",
    location: "Delhi"
  });

  console.log("Customers created");

  // Create Barbers/Owners
  const barber1 = await storage.createUser({
    name: "Vikram Barber",
    phone: "1122334455",
    role: "barber"
  });

  const barber2 = await storage.createUser({
    name: "Suresh Salon",
    phone: "5544332211",
    role: "barber"
  });

  console.log("Barbers created");

  // Create Salons
  const salon1 = await storage.createSalon({
    ownerId: barber1.id,
    name: "Vikram's Hair Studio",
    location: "Andheri West, Mumbai",
    phone: "1122334455",
    isOpen: true,
    isOnBreak: false
  });

  const salon2 = await storage.createSalon({
    ownerId: barber2.id,
    name: "Suresh Men's Parlour",
    location: "Connaught Place, Delhi",
    phone: "5544332211",
    isOpen: true,
    isOnBreak: true // Testing break status
  });

  console.log("Salons created");

  // Create Services
  // Salon 1
  const s1_haircut = await storage.createService({
    salonId: salon1.id,
    name: "Hair Cut",
    durationMinutes: 30,
    price: 150
  });
  
  const s1_shave = await storage.createService({
    salonId: salon1.id,
    name: "Shaving",
    durationMinutes: 15,
    price: 80
  });

  const s1_combo = await storage.createService({
    salonId: salon1.id,
    name: "Hair Cut + Shaving",
    durationMinutes: 45,
    price: 200
  });

  // Salon 2
  await storage.createService({
    salonId: salon2.id,
    name: "Classic Hair Cut",
    durationMinutes: 40,
    price: 100
  });

  console.log("Services created");

  // Create Queue Entries (Mock Data)
  // Salon 1 Queue
  await storage.addToQueue({
    salonId: salon1.id,
    customerId: cust1.id,
    serviceId: s1_haircut.id,
    tokenNumber: 1,
    status: "waiting",
    estimatedWaitMinutes: 0
  });

  await storage.updateSalonStatus(salon1.id, { lastIssuedToken: 1 });

  console.log("Queue seeded");
  console.log("Seeding complete!");
}

seed().catch(console.error);
import { useState } from "react";
import { Header } from "@/components/Header";
import { BottomNav } from "@/components/BottomNav";
import { useSalons } from "@/hooks/use-salons";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Search, MapPin, Clock, Star } from "lucide-react";
import { Link } from "wouter";

export default function CustomerHome() {
  const [search, setSearch] = useState("");
  const { data: salons, isLoading } = useSalons(search);

  return (
    <div className="min-h-screen bg-secondary/30 pb-20">
      <Header title="Find a Salon" subtitle="Book your next look" />
      
      <div className="max-w-md mx-auto p-4 space-y-6">
        {/* Search Bar */}
        <div className="relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 text-muted-foreground w-5 h-5" />
          <Input 
            className="pl-10 bg-white border-0 shadow-sm h-12 rounded-xl"
            placeholder="Search salons, services..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
          />
        </div>

        {/* Featured Section (Mock) */}
        {!search && (
          <div className="space-y-3">
            <h3 className="font-semibold text-lg">Nearby Favorites</h3>
            <div className="flex gap-4 overflow-x-auto pb-4 -mx-4 px-4 snap-x">
              {/* Using Unsplash with comments */}
              {/* barber shop interior modern */}
              <div className="snap-center shrink-0 w-64 h-40 rounded-2xl overflow-hidden relative shadow-md">
                <img 
                  src="https://images.unsplash.com/photo-1585747860715-2ba37e788b70?w=500&h=300&fit=crop" 
                  alt="Modern Cuts" 
                  className="w-full h-full object-cover"
                />
                <div className="absolute inset-0 bg-gradient-to-t from-black/80 to-transparent flex items-end p-3">
                  <div className="text-white">
                    <p className="font-bold">Modern Cuts</p>
                    <p className="text-xs opacity-80">1.2km away</p>
                  </div>
                </div>
              </div>
               {/* luxury salon interior */}
               <div className="snap-center shrink-0 w-64 h-40 rounded-2xl overflow-hidden relative shadow-md">
                <img 
                  src="https://images.unsplash.com/photo-1560066984-138dadb4c035?w=500&h=300&fit=crop" 
                  alt="Luxe Lounge" 
                  className="w-full h-full object-cover"
                />
                <div className="absolute inset-0 bg-gradient-to-t from-black/80 to-transparent flex items-end p-3">
                  <div className="text-white">
                    <p className="font-bold">Luxe Lounge</p>
                    <p className="text-xs opacity-80">2.5km away</p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Salon List */}
        <div className="space-y-4">
          <h3 className="font-semibold text-lg">All Salons</h3>
          
          {isLoading ? (
            <div className="space-y-4">
              {[1, 2, 3].map(i => (
                <div key={i} className="h-24 bg-white rounded-2xl animate-pulse" />
              ))}
            </div>
          ) : salons?.length === 0 ? (
            <div className="text-center py-10 text-muted-foreground">
              <p>No salons found matching "{search}"</p>
            </div>
          ) : (
            salons?.map((salon) => (
              <Link key={salon.id} href={`/customer/salon/${salon.id}`}>
                <Card className="p-4 mb-4 card-hover cursor-pointer flex gap-4">
                  <div className="w-20 h-20 rounded-xl bg-gray-100 shrink-0 overflow-hidden">
                    {/* Placeholder salon image */}
                    <img 
                      src={`https://images.unsplash.com/photo-1503951914875-452162b7f30a?w=150&h=150&fit=crop&q=80`}
                      alt={salon.name}
                      className="w-full h-full object-cover"
                    />
                  </div>
                  <div className="flex-1">
                    <div className="flex justify-between items-start">
                      <h4 className="font-bold text-lg leading-tight">{salon.name}</h4>
                      <div className={`px-2 py-0.5 rounded-full text-[10px] font-bold uppercase tracking-wide ${salon.isOpen ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>
                        {salon.isOpen ? 'Open' : 'Closed'}
                      </div>
                    </div>
                    
                    <div className="flex items-center text-sm text-muted-foreground mt-1">
                      <MapPin className="w-3.5 h-3.5 mr-1" />
                      {salon.location}
                    </div>

                    <div className="flex items-center gap-4 mt-3">
                      <div className="flex items-center text-xs font-medium text-primary bg-primary/5 px-2 py-1 rounded-md">
                        <Clock className="w-3 h-3 mr-1" />
                        Wait: ~20m
                      </div>
                      <div className="flex items-center text-xs font-medium text-amber-600 bg-amber-50 px-2 py-1 rounded-md">
                        <Star className="w-3 h-3 mr-1 fill-current" />
                        4.8
                      </div>
                    </div>
                  </div>
                </Card>
              </Link>
            ))
          )}
        </div>
      </div>
      <BottomNav role="customer" />
    </div>
  );
}
import { useRoute, useLocation } from "wouter";
import { useSalon, useSalonQueueStatus } from "@/hooks/use-salons";
import { useServices } from "@/hooks/use-services";
import { useJoinQueue } from "@/hooks/use-queue";
import { useAuth } from "@/hooks/use-auth";
import { Header } from "@/components/Header";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { 
  Clock, MapPin, Phone, Users, ChevronLeft, 
  CheckCircle2, AlertCircle 
} from "lucide-react";
import { useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog";

export default function SalonDetail() {
  const [match, params] = useRoute("/customer/salon/:id");
  const id = parseInt(params?.id || "0");
  const [, setLocation] = useLocation();
  const { user } = useAuth();
  
  const { data: salon, isLoading: isSalonLoading } = useSalon(id);
  const { data: services, isLoading: isServicesLoading } = useServices(id);
  const { data: queueStatus } = useSalonQueueStatus(id);
  
  const { mutate: joinQueue, isPending: isJoining } = useJoinQueue();
  const [selectedService, setSelectedService] = useState<number | null>(null);
  const [showConfirm, setShowConfirm] = useState(false);

  if (isSalonLoading || isServicesLoading) return <div className="p-8 text-center">Loading salon details...</div>;
  if (!salon) return <div className="p-8 text-center">Salon not found</div>;

  const handleJoinQueue = () => {
    if (!selectedService || !user) return;
    
    joinQueue(
      { salonId: id, serviceId: selectedService, customerId: user.id },
      {
        onSuccess: () => {
          setShowConfirm(false);
          setLocation("/customer/my-tokens");
        }
      }
    );
  };

  const selectedServiceDetails = services?.find(s => s.id === selectedService);

  return (
    <div className="min-h-screen bg-background pb-24">
      {/* Hero Image */}
      <div className="relative h-48 w-full">
         {/* salon detail hero image */}
        <img 
          src="https://images.unsplash.com/photo-1633681926022-84c23e8cb2d6?w=800&h=400&fit=crop" 
          alt="Salon Interior" 
          className="w-full h-full object-cover"
        />
        <div className="absolute inset-0 bg-black/40" />
        <Button 
          variant="secondary" 
          size="icon" 
          className="absolute top-4 left-4 rounded-full h-10 w-10"
          onClick={() => setLocation("/customer")}
        >
          <ChevronLeft className="w-6 h-6" />
        </Button>
      </div>

      <div className="max-w-md mx-auto px-4 -mt-6 relative">
        <Card className="p-5 shadow-lg border-none">
          <div className="flex justify-between items-start">
            <div>
              <h1 className="text-2xl font-bold font-display">{salon.name}</h1>
              <div className="flex items-center text-muted-foreground text-sm mt-1">
                <MapPin className="w-3.5 h-3.5 mr-1" />
                {salon.location}
              </div>
            </div>
            <div className={`px-3 py-1 rounded-full text-xs font-bold uppercase ${salon.isOpen ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>
              {salon.isOpen ? 'Open' : 'Closed'}
            </div>
          </div>

          <div className="grid grid-cols-3 gap-2 mt-6">
            <div className="bg-secondary/50 p-3 rounded-xl text-center">
              <p className="text-xs text-muted-foreground uppercase font-bold tracking-wider">Waiting</p>
              <p className="text-xl font-bold text-primary">{queueStatus?.queueLength || 0}</p>
            </div>
            <div className="bg-secondary/50 p-3 rounded-xl text-center">
              <p className="text-xs text-muted-foreground uppercase font-bold tracking-wider">Current</p>
              <p className="text-xl font-bold text-primary">#{queueStatus?.currentToken || 0}</p>
            </div>
            <div className="bg-secondary/50 p-3 rounded-xl text-center">
              <p className="text-xs text-muted-foreground uppercase font-bold tracking-wider">Wait Time</p>
              <p className="text-xl font-bold text-primary">{queueStatus?.totalWaitTimeMinutes || 0}m</p>
            </div>
          </div>
        </Card>

        <div className="mt-8">
          <h2 className="text-lg font-bold mb-4 flex items-center gap-2">
            <ScissorsIcon className="w-5 h-5 text-primary" />
            Select Service
          </h2>
          
          <div className="space-y-3">
            {services?.map((service) => (
              <div 
                key={service.id}
                onClick={() => setSelectedService(service.id)}
                className={`
                  p-4 rounded-xl border cursor-pointer transition-all flex justify-between items-center
                  ${selectedService === service.id 
                    ? 'border-primary bg-primary/5 shadow-md' 
                    : 'border-border bg-white hover:border-primary/30'}
                `}
              >
                <div>
                  <h3 className="font-semibold">{service.name}</h3>
                  <p className="text-sm text-muted-foreground flex items-center mt-1">
                    <Clock className="w-3.5 h-3.5 mr-1" />
                    {service.durationMinutes} mins
                  </p>
                </div>
                <div className="text-right">
                  <p className="font-bold text-primary">â‚¹{service.price}</p>
                  {selectedService === service.id && (
                    <CheckCircle2 className="w-5 h-5 text-primary mt-1 ml-auto" />
                  )}
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>

      <div className="fixed bottom-0 left-0 right-0 p-4 bg-white border-t safe-area-bottom">
        <Button 
          className="w-full btn-primary h-14 text-lg" 
          disabled={!selectedService || !salon.isOpen}
          onClick={() => setShowConfirm(true)}
        >
          {!salon.isOpen ? "Salon is Closed" : "Get Token"}
        </Button>
      </div>

      <Dialog open={showConfirm} onOpenChange={setShowConfirm}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Confirm Booking</DialogTitle>
            <DialogDescription>
              You are joining the queue at <strong>{salon.name}</strong>.
            </DialogDescription>
          </DialogHeader>
          
          <div className="bg-secondary/30 p-4 rounded-xl space-y-3">
            <div className="flex justify-between">
              <span className="text-muted-foreground">Service</span>
              <span className="font-semibold">{selectedServiceDetails?.name}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">Price</span>
              <span className="font-semibold">â‚¹{selectedServiceDetails?.price}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">Est. Wait</span>
              <span className="font-semibold text-primary">~{queueStatus?.totalWaitTimeMinutes || 15} mins</span>
            </div>
          </div>

          <div className="flex gap-3 mt-4">
            <Button variant="outline" className="flex-1" onClick={() => setShowConfirm(false)}>Cancel</Button>
            <Button 
              className="flex-1 btn-primary" 
              onClick={handleJoinQueue}
              disabled={isJoining}
            >
              {isJoining ? "Confirming..." : "Confirm & Join"}
            </Button>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}

function ScissorsIcon(props: any) {
  return (
    <svg 
      xmlns="http://www.w3.org/2000/svg" 
      width="24" 
      height="24" 
      viewBox="0 0 24 24" 
      fill="none" 
      stroke="currentColor" 
      strokeWidth="2" 
      strokeLinecap="round" 
      strokeLinejoin="round" 
      {...props}
    >
      <circle cx="6" cy="6" r="3" />
      <circle cx="6" cy="18" r="3" />
      <line x1="20" x2="8.12" y1="4" y2="15.88" />
      <line x1="14.47" x2="20" y1="14.48" y2="20" />
      <line x1="8.12" x2="12" y1="8.12" y2="12" />
    </svg>
  );
}
import { useMyQueue, useUpdateQueueItem } from "@/hooks/use-queue";
import { Header } from "@/components/Header";
import { BottomNav } from "@/components/BottomNav";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Ticket, MapPin, Loader2, CalendarX } from "lucide-react";

export default function MyTokens() {
  const { data: queueItems, isLoading } = useMyQueue();
  const { mutate: updateStatus, isPending } = useUpdateQueueItem();

  const handleCancel = (id: number) => {
    if (confirm("Are you sure you want to leave the queue?")) {
      updateStatus({ id, status: 'cancelled' });
    }
  };

  return (
    <div className="min-h-screen bg-secondary/30 pb-20">
      <Header title="My Tokens" subtitle="Track your position in real-time" />
      
      <div className="max-w-md mx-auto p-4 space-y-6">
        {isLoading ? (
          <div className="flex justify-center py-12">
            <Loader2 className="w-8 h-8 animate-spin text-primary" />
          </div>
        ) : queueItems?.length === 0 ? (
          <div className="text-center py-16 px-4">
            <div className="w-20 h-20 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-6">
              <Ticket className="w-10 h-10 text-muted-foreground" />
            </div>
            <h3 className="text-xl font-bold mb-2">No Active Tokens</h3>
            <p className="text-muted-foreground mb-6">You aren't in any queues right now.</p>
            <Button asChild className="btn-primary">
              <a href="/customer">Find a Salon</a>
            </Button>
          </div>
        ) : (
          queueItems?.map((item) => (
            <Card key={item.id} className="overflow-hidden border-0 shadow-lg relative">
              <div className="bg-primary px-6 py-8 text-white text-center relative overflow-hidden">
                <div className="absolute top-0 left-0 w-full h-full bg-[url('https://www.transparenttextures.com/patterns/cubes.png')] opacity-10"></div>
                <p className="text-primary-foreground/80 font-medium tracking-widest text-sm uppercase mb-1">Token Number</p>
                <h2 className="text-6xl font-bold font-display">{item.tokenNumber}</h2>
              </div>
              
              <div className="p-6 bg-white">
                <h3 className="text-xl font-bold mb-1">{item.salon.name}</h3>
                <div className="flex items-center text-sm text-muted-foreground mb-6">
                  <MapPin className="w-3.5 h-3.5 mr-1" />
                  {item.salon.location}
                </div>

                <div className="grid grid-cols-2 gap-4 mb-6">
                  <div className="bg-secondary/50 p-3 rounded-lg">
                    <p className="text-xs text-muted-foreground uppercase font-bold">Your Position</p>
                    <p className="text-xl font-bold">{item.position}</p>
                  </div>
                  <div className="bg-secondary/50 p-3 rounded-lg">
                    <p className="text-xs text-muted-foreground uppercase font-bold">Est. Wait</p>
                    <p className="text-xl font-bold text-primary">{item.estimatedWaitMinutes} min</p>
                  </div>
                </div>

                <div className="flex justify-between items-center pt-4 border-t border-dashed">
                  <div>
                    <p className="text-sm font-medium">{item.service.name}</p>
                    <p className="text-sm text-muted-foreground">â‚¹{item.service.price}</p>
                  </div>
                  <Button 
                    variant="destructive" 
                    size="sm" 
                    onClick={() => handleCancel(item.id)}
                    disabled={isPending}
                  >
                    <CalendarX className="w-4 h-4 mr-2" />
                    Cancel
                  </Button>
                </div>
              </div>
            </Card>
          ))
        )}
      </div>
      <BottomNav role="customer" />
    </div>
  );
}
import { useAuth } from "@/hooks/use-auth";
import { Header } from "@/components/Header";
import { BottomNav } from "@/components/BottomNav";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { CreditCard, History, Settings, LogOut, Crown } from "lucide-react";

export default function CustomerProfile() {
  const { user, logout } = useAuth();

  return (
    <div className="min-h-screen bg-secondary/30 pb-20">
      <Header title="Profile" showLogout={false} />
      
      <div className="max-w-md mx-auto p-4 space-y-6">
        <div className="flex items-center gap-4 bg-white p-6 rounded-2xl shadow-sm border border-border/50">
          <Avatar className="w-16 h-16 border-2 border-primary/20">
            <AvatarImage src={`https://api.dicebear.com/7.x/initials/svg?seed=${user?.name}`} />
            <AvatarFallback>{user?.name?.[0]}</AvatarFallback>
          </Avatar>
          <div>
            <h2 className="text-xl font-bold">{user?.name || "Guest User"}</h2>
            <p className="text-muted-foreground">{user?.phone}</p>
          </div>
        </div>

        <div className="space-y-3">
          <h3 className="text-sm font-bold text-muted-foreground uppercase tracking-wider ml-1">Membership</h3>
          <Card className="p-6 bg-gradient-to-br from-indigo-900 to-purple-800 text-white border-none shadow-xl relative overflow-hidden">
            <div className="relative z-10">
              <div className="flex justify-between items-start mb-4">
                <div>
                  <h3 className="text-lg font-bold">Free Plan</h3>
                  <p className="text-indigo-200 text-sm">Upgrade for faster service</p>
                </div>
                <Crown className="w-6 h-6 text-yellow-400 fill-current" />
              </div>
              <Button size="sm" className="bg-white text-indigo-900 hover:bg-white/90 font-bold border-none">
                Upgrade to Premium
              </Button>
            </div>
            {/* Abstract background shape */}
            <div className="absolute -right-10 -bottom-10 w-40 h-40 bg-white/10 rounded-full blur-2xl"></div>
          </Card>
        </div>

        <div className="space-y-3">
          <h3 className="text-sm font-bold text-muted-foreground uppercase tracking-wider ml-1">Settings</h3>
          <div className="bg-white rounded-2xl overflow-hidden shadow-sm border border-border/50">
            <MenuItem icon={History} label="Booking History" />
            <div className="h-[1px] bg-border/50 mx-4" />
            <MenuItem icon={CreditCard} label="Payment Methods" />
            <div className="h-[1px] bg-border/50 mx-4" />
            <MenuItem icon={Settings} label="Preferences" />
            <div className="h-[1px] bg-border/50 mx-4" />
            <MenuItem icon={LogOut} label="Log Out" onClick={logout} className="text-destructive" />
          </div>
        </div>
      </div>
      <BottomNav role="customer" />
    </div>
  );
}

function MenuItem({ icon: Icon, label, onClick, className = "" }: any) {
  return (
    <div 
      onClick={onClick}
      className={`p-4 flex items-center cursor-pointer hover:bg-secondary/50 transition-colors ${className}`}
    >
      <div className="w-8 h-8 rounded-full bg-secondary flex items-center justify-center mr-4">
        <Icon className="w-4 h-4 opacity-70" />
      </div>
      <span className="font-medium">{label}</span>
    </div>
  );
}
import { useMySalon, useUpdateSalonStatus, useSalonQueueStatus } from "@/hooks/use-salons";
import { Header } from "@/components/Header";
import { BottomNav } from "@/components/BottomNav";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Scissors, Coffee, Power, Users, Clock } from "lucide-react";
import { useLocation } from "wouter";

export default function BarberDashboard() {
  const { data: salon, isLoading } = useMySalon();
  const [, setLocation] = useLocation();
  const { mutate: updateStatus } = useUpdateSalonStatus();
  
  // Also fetch queue stats for live dashboard
  const { data: stats } = useSalonQueueStatus(salon?.id || 0);

  if (isLoading) return <div className="p-8 text-center">Loading dashboard...</div>;
  
  // If no salon yet, redirect to setup
  if (!salon && !isLoading) {
    setLocation("/barber/setup");
    return null;
  }

  const handleToggleOpen = () => {
    updateStatus({ 
      id: salon.id, 
      action: salon.isOpen ? 'close' : 'open',
      isOpen: !salon.isOpen 
    });
  };

  const handleToggleBreak = () => {
    updateStatus({ 
      id: salon.id, 
      action: salon.isOnBreak ? 'break_end' : 'break_start',
      isOnBreak: !salon.isOnBreak 
    });
  };

  return (
    <div className="min-h-screen bg-secondary/30 pb-20">
      <Header title="Salon Dashboard" subtitle={salon.name} />

      <div className="max-w-md mx-auto p-4 space-y-6">
        {/* Status Control Cards */}
        <div className="grid grid-cols-2 gap-4">
          <Card className={`p-5 flex flex-col justify-between h-32 transition-all ${salon.isOpen ? 'bg-green-600 text-white shadow-lg shadow-green-200' : 'bg-white'}`}>
            <div className="flex justify-between items-start">
              <Power className={`w-6 h-6 ${salon.isOpen ? 'opacity-80' : 'text-muted-foreground'}`} />
              <Switch 
                checked={salon.isOpen} 
                onCheckedChange={handleToggleOpen}
                className="data-[state=checked]:bg-white/20 data-[state=unchecked]:bg-slate-200"
              />
            </div>
            <div>
              <p className={`text-xs font-bold uppercase tracking-wider ${salon.isOpen ? 'text-white/80' : 'text-muted-foreground'}`}>Salon Status</p>
              <h3 className="text-xl font-bold">{salon.isOpen ? 'OPEN' : 'CLOSED'}</h3>
            </div>
          </Card>

          <Card className={`p-5 flex flex-col justify-between h-32 transition-all ${salon.isOnBreak ? 'bg-amber-500 text-white shadow-lg shadow-amber-200' : 'bg-white'}`}>
            <div className="flex justify-between items-start">
              <Coffee className={`w-6 h-6 ${salon.isOnBreak ? 'opacity-80' : 'text-muted-foreground'}`} />
              <Switch 
                checked={salon.isOnBreak} 
                onCheckedChange={handleToggleBreak}
                disabled={!salon.isOpen}
                className="data-[state=checked]:bg-white/20 data-[state=unchecked]:bg-slate-200"
              />
            </div>
            <div>
              <p className={`text-xs font-bold uppercase tracking-wider ${salon.isOnBreak ? 'text-white/80' : 'text-muted-foreground'}`}>Break Mode</p>
              <h3 className="text-xl font-bold">{salon.isOnBreak ? 'ON BREAK' : 'WORKING'}</h3>
            </div>
          </Card>
        </div>

        {/* Live Stats */}
        <h3 className="font-bold text-lg px-1">Live Overview</h3>
        <div className="grid grid-cols-3 gap-3">
          <StatsCard label="Waiting" value={stats?.queueLength || 0} icon={Users} color="text-blue-600" bg="bg-blue-50" />
          <StatsCard label="Served" value={stats?.lastIssuedToken || 0} icon={Scissors} color="text-purple-600" bg="bg-purple-50" />
          <StatsCard label="Wait Time" value={`${stats?.totalWaitTimeMinutes || 0}m`} icon={Clock} color="text-orange-600" bg="bg-orange-50" />
        </div>

        {/* Actions */}
        <div className="space-y-4 pt-4">
           <Button className="w-full h-14 text-lg btn-primary" onClick={() => setLocation("/barber/queue")}>
             Manage Queue
           </Button>
           <Button variant="outline" className="w-full h-12" onClick={() => setLocation("/barber/services")}>
             Manage Services
           </Button>
        </div>
      </div>

      <BottomNav role="barber" />
    </div>
  );
}

function StatsCard({ label, value, icon: Icon, color, bg }: any) {
  return (
    <Card className="p-4 flex flex-col items-center justify-center text-center space-y-2 border-0 shadow-sm">
      <div className={`w-10 h-10 rounded-full ${bg} flex items-center justify-center`}>
        <Icon className={`w-5 h-5 ${color}`} />
      </div>
      <div>
        <h4 className="text-2xl font-bold font-display">{value}</h4>
        <p className="text-xs text-muted-foreground font-medium">{label}</p>
      </div>
    </Card>
  );
}
import { useMySalon, useSalonQueueStatus } from "@/hooks/use-salons";
import { useSalonQueue, useNextCustomer } from "@/hooks/use-queue";
import { Header } from "@/components/Header";
import { BottomNav } from "@/components/BottomNav";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Loader2, User, Clock, CheckCircle2 } from "lucide-react";
import { useLocation } from "wouter";

export default function QueueManagement() {
  const { data: salon } = useMySalon();
  const [, setLocation] = useLocation();
  const salonId = salon?.id || 0;
  
  const { data: queue, isLoading } = useSalonQueue(salonId);
  const { data: stats } = useSalonQueueStatus(salonId);
  const { mutate: callNext, isPending: isCallingNext } = useNextCustomer();

  if (!salon) return null;

  const currentCustomer = queue?.find(item => item.tokenNumber === stats?.currentToken && item.status === 'waiting');
  const waitingList = queue?.filter(item => item.tokenNumber > (stats?.currentToken || 0) && item.status === 'waiting');

  return (
    <div className="min-h-screen bg-secondary/30 pb-20">
      <Header title="Queue Control" subtitle={`Current Token: #${stats?.currentToken || 0}`} />

      <div className="max-w-md mx-auto p-4 space-y-6">
        
        {/* Current Customer Card - Big and Prominent */}
        <div className="bg-white rounded-3xl p-6 shadow-xl border-t-4 border-primary text-center space-y-6">
          <p className="text-sm font-bold text-muted-foreground uppercase tracking-widest">Now Serving</p>
          
          {currentCustomer ? (
            <div className="animate-in zoom-in duration-300">
              <div className="text-8xl font-bold text-foreground font-display mb-2">
                {currentCustomer.tokenNumber}
              </div>
              <h3 className="text-2xl font-bold text-primary mb-1">{currentCustomer.customer.name}</h3>
              <p className="text-lg text-muted-foreground">{currentCustomer.service.name}</p>
              
              <div className="mt-8">
                <Button 
                  size="lg" 
                  className="w-full h-16 text-xl rounded-2xl shadow-lg shadow-primary/20 hover:shadow-primary/40 transition-all"
                  onClick={() => callNext(salonId)}
                  disabled={isCallingNext}
                >
                  {isCallingNext ? <Loader2 className="animate-spin mr-2" /> : <CheckCircle2 className="mr-2" />}
                  Complete & Next
                </Button>
              </div>
            </div>
          ) : (
            <div className="py-8">
              <div className="text-6xl font-bold text-muted-foreground/30 font-display mb-4">--</div>
              <p className="text-lg text-muted-foreground">No active customer</p>
              <Button 
                className="mt-6 w-full btn-primary"
                onClick={() => callNext(salonId)}
                disabled={waitingList?.length === 0 || isCallingNext}
              >
                Call First Customer
              </Button>
            </div>
          )}
        </div>

        {/* Up Next List */}
        <div>
          <h3 className="font-bold text-lg px-2 mb-3">Up Next ({waitingList?.length || 0})</h3>
          
          <div className="space-y-3">
            {isLoading ? (
               <div className="text-center py-4"><Loader2 className="animate-spin inline" /></div>
            ) : waitingList?.length === 0 ? (
              <div className="text-center py-8 text-muted-foreground bg-white rounded-xl border border-dashed">
                <p>Queue is empty</p>
              </div>
            ) : (
              waitingList?.map((item) => (
                <Card key={item.id} className="p-4 flex items-center justify-between shadow-sm border-0">
                  <div className="flex items-center gap-4">
                    <div className="w-12 h-12 rounded-xl bg-secondary flex items-center justify-center font-bold text-xl text-primary">
                      {item.tokenNumber}
                    </div>
                    <div>
                      <h4 className="font-bold">{item.customer.name}</h4>
                      <p className="text-sm text-muted-foreground">{item.service.name}</p>
                    </div>
                  </div>
                  <div className="text-right">
                    <p className="text-xs text-muted-foreground flex items-center justify-end">
                      <Clock className="w-3 h-3 mr-1" />
                      ~{item.estimatedWaitMinutes}m
                    </p>
                  </div>
                </Card>
              ))
            )}
          </div>
        </div>

      </div>
      <BottomNav role="barber" />
    </div>
  );
}
import { useState } from "react";
import { useCreateSalon } from "@/hooks/use-salons";
import { useAuth } from "@/hooks/use-auth";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useLocation } from "wouter";
import { Scissors } from "lucide-react";

export default function BarberSetup() {
  const { user } = useAuth();
  const { mutate: createSalon, isPending } = useCreateSalon();
  const [, setLocation] = useLocation();

  const [formData, setFormData] = useState({
    name: "",
    location: "",
    phone: user?.phone || "",
    ownerId: user?.id || 0
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!user) return;
    
    createSalon({
      ...formData,
      ownerId: user.id
    }, {
      onSuccess: () => setLocation("/barber")
    });
  };

  return (
    <div className="min-h-screen bg-background flex flex-col justify-center p-6 max-w-md mx-auto">
      <div className="text-center mb-8">
        <div className="w-16 h-16 bg-primary/10 rounded-2xl flex items-center justify-center mx-auto mb-4">
          <Scissors className="w-8 h-8 text-primary" />
        </div>
        <h1 className="text-3xl font-bold font-display">Setup Your Salon</h1>
        <p className="text-muted-foreground mt-2">Let's get your business online</p>
      </div>

      <form onSubmit={handleSubmit} className="space-y-6">
        <div className="space-y-2">
          <label className="text-sm font-medium">Salon Name</label>
          <Input 
            className="input-modern"
            placeholder="e.g. Classic Cuts"
            value={formData.name}
            onChange={e => setFormData({...formData, name: e.target.value})}
            required
          />
        </div>

        <div className="space-y-2">
          <label className="text-sm font-medium">Location</label>
          <Input 
            className="input-modern"
            placeholder="e.g. Downtown, Main St."
            value={formData.location}
            onChange={e => setFormData({...formData, location: e.target.value})}
            required
          />
        </div>

        <div className="space-y-2">
          <label className="text-sm font-medium">Contact Number</label>
          <Input 
            className="input-modern"
            value={formData.phone}
            onChange={e => setFormData({...formData, phone: e.target.value})}
            required
          />
        </div>

        <Button type="submit" className="w-full btn-primary h-12 text-lg mt-8" disabled={isPending}>
          {isPending ? "Creating..." : "Launch Salon"}
        </Button>
      </form>
    </div>
  );
}
import { Switch, Route, useLocation } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import { useAuth } from "@/hooks/use-auth";
import { useEffect } from "react";

// Pages
import NotFound from "@/pages/not-found";
import Login from "@/pages/Login";

// Customer Pages
import CustomerHome from "@/pages/customer/Home";
import SalonDetail from "@/pages/customer/SalonDetail";
import MyTokens from "@/pages/customer/MyTokens";
import CustomerProfile from "@/pages/customer/Profile";

// Barber Pages
import BarberDashboard from "@/pages/barber/Dashboard";
import QueueManagement from "@/pages/barber/QueueManagement";
import BarberSetup from "@/pages/barber/Setup";

function ProtectedRoute({ component: Component, allowedRole }: { component: any, allowedRole?: string }) {
  const { user } = useAuth();
  const [, setLocation] = useLocation();

  useEffect(() => {
    if (!user) {
      setLocation("/");
    } else if (allowedRole && user.role !== allowedRole) {
      // Redirect to correct dashboard if trying to access wrong role pages
      setLocation(user.role === "barber" ? "/barber" : "/customer");
    }
  }, [user, allowedRole, setLocation]);

  if (!user) return null;
  return <Component />;
}

function Router() {
  return (
    <Switch>
      {/* Public */}
      <Route path="/" component={Login} />
      
      {/* Customer Routes */}
      <Route path="/customer">
        <ProtectedRoute component={CustomerHome} allowedRole="customer" />
      </Route>
      <Route path="/customer/salon/:id">
        <ProtectedRoute component={SalonDetail} allowedRole="customer" />
      </Route>
      <Route path="/customer/my-tokens">
        <ProtectedRoute component={MyTokens} allowedRole="customer" />
      </Route>
      <Route path="/customer/profile">
        <ProtectedRoute component={CustomerProfile} allowedRole="customer" />
      </Route>

      {/* Barber Routes */}
      <Route path="/barber">
        <ProtectedRoute component={BarberDashboard} allowedRole="barber" />
      </Route>
      <Route path="/barber/queue">
        <ProtectedRoute component={QueueManagement} allowedRole="barber" />
      </Route>
      <Route path="/barber/setup">
        <ProtectedRoute component={BarberSetup} allowedRole="barber" />
      </Route>
      {/* <Route path="/barber/profile" component={BarberProfile} /> */}

      {/* Fallback */}
      <Route component={NotFound} />
    </Switch>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <TooltipProvider>
        <Toaster />
        <Router />
      </TooltipProvider>
    </QueryClientProvider>
  );
}

        ReactDOM.createRoot(document.getElementById('root')).render(<Root />);
    </script>
</body>
</html>
